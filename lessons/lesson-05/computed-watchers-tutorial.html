<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computed Properties & Watchers Tutorial - Step by Step</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
            background: #f6f9fc;
        }
        .step {
            background: white;
            padding: 25px;
            border-radius: 8px;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .step h2 {
            color: #42b983;
            border-bottom: 2px solid #42b983;
            padding-bottom: 10px;
        }
        .explanation {
            background: #e8f5e9;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #42b983;
        }
        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 15px 0;
            white-space: pre-wrap;
            font-family: 'Courier New', Courier, monospace;
            line-height: 1.6;
            word-wrap: break-word;
        }
        .demo-app {
            background: #fff;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            margin: 20px 0;
        }
        .tip {
            background: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
        }
        .warning {
            background: #f8d7da;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #dc3545;
            margin: 15px 0;
        }
        code {
            background: #f0f0f0;
            padding: 2px 6px;
            border-radius: 3px;
            color: #d63384;
        }
        input {
            padding: 8px;
            margin: 5px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 200px;
        }
        .demo-box {
            border: 2px solid #42b983;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background: #42b983;
            color: white;
        }
    </style>
</head>
<body>
    <h1>üìö Computed Properties & Watchers - Step by Step Tutorial</h1>
    <p style="font-size: 1.1em; color: #666;">Learn when and how to use computed properties and watchers in Vue.js. Master the difference between computed, methods, and watchers!</p>

    <!-- STEP 1 -->
    <div class="step">
        <h2>Step 1: Understanding the Problem - Why Computed Properties?</h2>
        <div class="explanation">
            <p><strong>What we're doing:</strong> Understanding when to use computed properties vs methods.</p>
            <p><strong>Key concept:</strong> Computed properties are <strong>cached</strong> - they only recalculate when their dependencies change!</p>
        </div>
        
        <div class="code-block">
// ‚ùå BAD: Using a method for derived data
methods: {
    getFullName() {
        return `${this.firstName} ${this.lastName}`;
    }
}
// This runs EVERY time it's called, even if firstName/lastName didn't change!

// ‚úÖ GOOD: Using computed property
computed: {
    fullName() {
        return `${this.firstName} ${this.lastName}`;
    }
}
// This only recalculates when firstName or lastName changes!
        </div>

        <div class="explanation">
            <p><strong>When to use Computed:</strong></p>
            <ul>
                <li>Displaying filtered/sorted lists</li>
                <li>Calculations based on other data</li>
                <li>Derived values that depend on reactive data</li>
                <li>Any time you need <strong>cached</strong> results</li>
            </ul>
        </div>
    </div>

    <!-- STEP 2 -->
    <div class="step">
        <h2>Step 2: Creating Your First Computed Property</h2>
        <div class="explanation">
            <p><strong>What we're doing:</strong> Create a computed property that combines first and last name.</p>
            <p><strong>Key concept:</strong> Computed properties are defined in the <code>computed</code> option and accessed like data properties.</p>
        </div>
        
        <div class="code-block">
data() {
    return {
        firstName: 'John',
        lastName: 'Doe'
    }
},
computed: {
    fullName() {
        console.log('Computed: fullName recalculated');
        return `${this.firstName} ${this.lastName}`.trim();
    }
}
        </div>

        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <ul>
                <li>Computed properties are functions that return a value</li>
                <li>They automatically track dependencies (firstName, lastName)</li>
                <li>Access them in template like: <code>{{ fullName }}</code> (no parentheses!)</li>
                <li>They're cached - only recalculate when dependencies change</li>
            </ul>
        </div>

        <div class="demo-app">
            <h3>Live Demo:</h3>
            <div id="demo1">
                <input v-model="firstName" placeholder="First Name">
                <input v-model="lastName" placeholder="Last Name">
                <p><strong>Full Name (Computed):</strong> {{ fullName }}</p>
                <p><small>Open console to see when it recalculates!</small></p>
            </div>
        </div>
    </div>

    <!-- STEP 3 -->
    <div class="step">
        <h2>Step 3: Computed vs Method - See the Difference</h2>
        <div class="explanation">
            <p><strong>What we're doing:</strong> Compare computed property with a method to see the caching difference.</p>
            <p><strong>Key concept:</strong> Methods run every time; computed properties only run when dependencies change.</p>
        </div>
        
        <div class="code-block">
data() {
    return {
        price: 10,
        quantity: 2
    }
},
computed: {
    total() {
        console.log('Computed: total recalculated');
        return (this.price * this.quantity).toFixed(2);
    }
},
methods: {
    getTotal() {
        console.log('Method: getTotal called');
        return (this.price * this.quantity).toFixed(2);
    }
}
        </div>

        <div class="tip">
            <strong>üí° Tip:</strong> Open your browser console and watch the logs. The computed property only logs when price or quantity changes, but the method logs every time it's accessed!
        </div>

        <div class="demo-app">
            <h3>Live Demo:</h3>
            <div id="demo2">
                <input v-model.number="price" type="number" placeholder="Price">
                <input v-model.number="quantity" type="number" placeholder="Quantity">
                <p><strong>Total (Computed):</strong> ${{ total }}</p>
                <p><strong>Total (Method):</strong> ${{ getTotal() }}</p>
                <p><small>Open console to see the difference!</small></p>
            </div>
        </div>
    </div>

    <!-- STEP 4 -->
    <div class="step">
        <h2>Step 4: Computed Property with Filtering</h2>
        <div class="explanation">
            <p><strong>What we're doing:</strong> Use computed property to filter a list based on search query.</p>
            <p><strong>Key concept:</strong> Computed properties are perfect for filtering, sorting, and transforming data.</p>
        </div>
        
        <div class="code-block">
data() {
    return {
        searchQuery: '',
        items: [
            { id: 1, name: 'Apple' },
            { id: 2, name: 'Banana' },
            { id: 3, name: 'Cherry' },
            { id: 4, name: 'Date' },
            { id: 5, name: 'Elderberry' }
        ]
    }
},
computed: {
    filteredItems() {
        if (!this.searchQuery) {
            return this.items;
        }
        return this.items.filter(item => 
            item.name.toLowerCase().includes(this.searchQuery.toLowerCase())
        );
    }
}
        </div>

        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <ul>
                <li>Computed property automatically tracks <code>searchQuery</code> and <code>items</code></li>
                <li>When either changes, the filtered list recalculates</li>
                <li>Much more efficient than filtering in a method!</li>
            </ul>
        </div>

        <div class="demo-app">
            <h3>Live Demo:</h3>
            <div id="demo3">
                <input v-model="searchQuery" placeholder="Search items...">
                <ul>
                    <li v-for="item in filteredItems" :key="item.id">
                        {{ item.name }}
                    </li>
                </ul>
                <p>Showing {{ filteredItems.length }} of {{ items.length }} items</p>
            </div>
        </div>
    </div>

    <!-- STEP 5 -->
    <div class="step">
        <h2>Step 5: Introduction to Watchers</h2>
        <div class="explanation">
            <p><strong>What we're doing:</strong> Learn when and how to use watchers.</p>
            <p><strong>Key concept:</strong> Watchers are for <strong>side effects</strong> - things that happen when data changes (API calls, logging, validation).</p>
        </div>
        
        <table>
            <tr>
                <th>Feature</th>
                <th>Computed</th>
                <th>Watcher</th>
            </tr>
            <tr>
                <td><strong>Purpose</strong></td>
                <td>Derived data</td>
                <td>Side effects</td>
            </tr>
            <tr>
                <td><strong>Returns value?</strong></td>
                <td>Yes</td>
                <td>No</td>
            </tr>
            <tr>
                <td><strong>Cached?</strong></td>
                <td>Yes</td>
                <td>No</td>
            </tr>
            <tr>
                <td><strong>Use for</strong></td>
                <td>Display calculations</td>
                <td>API calls, logging, validation</td>
            </tr>
        </table>

        <div class="code-block">
data() {
    return {
        watchedValue: '',
        previousValue: '',
        changeCount: 0
    }
},
watch: {
    watchedValue(newVal, oldVal) {
        this.previousValue = oldVal;
        this.changeCount++;
        console.log(`Value changed from "${oldVal}" to "${newVal}"`);
    }
}
        </div>

        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <ul>
                <li>Watchers receive two parameters: <code>newVal</code> and <code>oldVal</code></li>
                <li>They run automatically when the watched property changes</li>
                <li>Perfect for side effects like logging, API calls, or validation</li>
            </ul>
        </div>

        <div class="demo-app">
            <h3>Live Demo:</h3>
            <div id="demo4">
                <input v-model="watchedValue" placeholder="Type something...">
                <p>Current value: <strong>{{ watchedValue }}</strong></p>
                <p>Previous value: <strong>{{ previousValue }}</strong></p>
                <p>Change count: <strong>{{ changeCount }}</strong></p>
            </div>
        </div>
    </div>

    <!-- STEP 6 -->
    <div class="step">
        <h2>Step 6: Watcher with Async Operations</h2>
        <div class="explanation">
            <p><strong>What we're doing:</strong> Use a watcher to perform async operations like API calls.</p>
            <p><strong>Key concept:</strong> Watchers are perfect for async operations that should happen when data changes.</p>
        </div>
        
        <div class="code-block">
data() {
    return {
        username: '',
        loading: false,
        userData: ''
    }
},
watch: {
    username(newVal) {
        // Don't search if username is too short
        if (newVal.length < 3) {
            this.userData = '';
            return;
        }
        
        // Show loading state
        this.loading = true;
        this.userData = '';
        
        // Simulate API call
        setTimeout(() => {
            this.userData = `User data for: ${newVal}`;
            this.loading = false;
        }, 1000);
    }
}
        </div>

        <div class="warning">
            <strong>‚ö†Ô∏è Important:</strong> This is a perfect use case for watchers! You can't do async operations in computed properties. Use watchers for API calls, timers, or any side effects.
        </div>

        <div class="demo-app">
            <h3>Live Demo:</h3>
            <div id="demo5">
                <input v-model="username" placeholder="Enter username">
                <p v-if="loading">Loading...</p>
                <p v-else-if="userData">{{ userData }}</p>
            </div>
        </div>
    </div>

    <!-- STEP 7 -->
    <div class="step">
        <h2>Step 7: Building a Shopping Cart - Complete Example</h2>
        <div class="explanation">
            <p><strong>What we're doing:</strong> Build a complete shopping cart using computed properties and watchers.</p>
            <p><strong>Key concept:</strong> Use computed for calculations, watchers for side effects!</p>
        </div>
        
        <div class="code-block">
data() {
    return {
        products: [
            { id: 1, name: 'Apple', price: 1.50, quantity: 0 },
            { id: 2, name: 'Banana', price: 0.80, quantity: 0 },
            { id: 3, name: 'Cherry', price: 3.00, quantity: 0 }
        ],
        discountCode: '',
        warningShown: false
    }
},
computed: {
    totalPrice() {
        return this.products.reduce((sum, product) => {
            return sum + (product.price * product.quantity);
        }, 0);
    },
    itemCount() {
        return this.products.reduce((sum, product) => {
            return sum + product.quantity;
        }, 0);
    },
    discount() {
        return this.discountCode === 'SAVE10' ? 0.1 : 0;
    },
    finalPrice() {
        return this.totalPrice * (1 - this.discount);
    }
},
watch: {
    totalPrice(newVal) {
        if (newVal > 100 && !this.warningShown) {
            alert('Total exceeds $100!');
            this.warningShown = true;
        } else if (newVal <= 100) {
            this.warningShown = false;
        }
    }
}
        </div>

        <div class="explanation">
            <p><strong>Explanation:</strong></p>
            <ul>
                <li><code>totalPrice</code> - Computed: calculates total from products</li>
                <li><code>itemCount</code> - Computed: counts total items</li>
                <li><code>discount</code> - Computed: checks discount code</li>
                <li><code>finalPrice</code> - Computed: applies discount to total</li>
                <li><code>totalPrice</code> watcher - Shows alert when total exceeds $100</li>
            </ul>
        </div>

        <div class="demo-app">
            <h3>Complete Shopping Cart:</h3>
            <div id="demo6">
                <div v-for="product in products" :key="product.id" style="margin: 15px 0; padding: 10px; border: 1px solid #ddd; border-radius: 5px;">
                    <strong>{{ product.name }}</strong> - ${{ product.price.toFixed(2) }}
                    <input 
                        type="number" 
                        v-model.number="product.quantity" 
                        min="0" 
                        style="width: 80px; margin-left: 10px;">
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: #f0f0f0; border-radius: 5px;">
                    <p><strong>Items:</strong> {{ itemCount }}</p>
                    <p><strong>Subtotal:</strong> ${{ totalPrice.toFixed(2) }}</p>
                    <input v-model="discountCode" placeholder="Discount code" style="margin: 10px 0;">
                    <p v-if="discount > 0" style="color: green;"><strong>Discount applied: 10%</strong></p>
                    <p><strong>Total:</strong> ${{ finalPrice.toFixed(2) }}</p>
                </div>
            </div>
        </div>
    </div>

    <!-- KEY CONCEPTS -->
    <div class="step">
        <h2>üéì Key Concepts Summary</h2>
        <div class="explanation">
            <h3>Computed Properties:</h3>
            <ul>
                <li>‚úÖ <strong>Cached</strong> - Only recalculates when dependencies change</li>
                <li>‚úÖ <strong>Returns a value</strong> - Use for derived data</li>
                <li>‚úÖ <strong>Access like data</strong> - No parentheses: <code>{{ computedProp }}</code></li>
                <li>‚úÖ <strong>Use for:</strong> Calculations, filtering, sorting, formatting</li>
            </ul>
            
            <h3>Watchers:</h3>
            <ul>
                <li>‚úÖ <strong>Side effects</strong> - Runs when watched property changes</li>
                <li>‚úÖ <strong>No return value</strong> - Use for actions, not calculations</li>
                <li>‚úÖ <strong>Receives new/old values</strong> - <code>watch: { prop(newVal, oldVal) { } }</code></li>
                <li>‚úÖ <strong>Use for:</strong> API calls, logging, validation, alerts</li>
            </ul>
            
            <h3>Methods:</h3>
            <ul>
                <li>‚úÖ <strong>Not cached</strong> - Runs every time it's called</li>
                <li>‚úÖ <strong>Use for:</strong> Event handlers, actions, user interactions</li>
            </ul>
        </div>

        <div class="tip">
            <strong>üí° Quick Decision Guide:</strong><br>
            Need to <strong>calculate/display</strong> something? ‚Üí Use <strong>Computed</strong><br>
            Need to <strong>do something</strong> when data changes? ‚Üí Use <strong>Watcher</strong><br>
            Need to <strong>handle user action</strong>? ‚Üí Use <strong>Method</strong>
        </div>
    </div>

    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script>
        const { createApp } = Vue;
        
        // Demo 1: Full Name
        createApp({
            data() {
                return {
                    firstName: 'John',
                    lastName: 'Doe'
                }
            },
            computed: {
                fullName() {
                    console.log('Computed: fullName recalculated');
                    return `${this.firstName} ${this.lastName}`.trim();
                }
            }
        }).mount('#demo1');
        
        // Demo 2: Computed vs Method
        createApp({
            data() {
                return {
                    price: 10,
                    quantity: 2
                }
            },
            computed: {
                total() {
                    console.log('Computed: total recalculated');
                    return (this.price * this.quantity).toFixed(2);
                }
            },
            methods: {
                getTotal() {
                    console.log('Method: getTotal called');
                    return (this.price * this.quantity).toFixed(2);
                }
            }
        }).mount('#demo2');
        
        // Demo 3: Filtering
        createApp({
            data() {
                return {
                    searchQuery: '',
                    items: [
                        { id: 1, name: 'Apple' },
                        { id: 2, name: 'Banana' },
                        { id: 3, name: 'Cherry' },
                        { id: 4, name: 'Date' },
                        { id: 5, name: 'Elderberry' }
                    ]
                }
            },
            computed: {
                filteredItems() {
                    if (!this.searchQuery) {
                        return this.items;
                    }
                    return this.items.filter(item => 
                        item.name.toLowerCase().includes(this.searchQuery.toLowerCase())
                    );
                }
            }
        }).mount('#demo3');
        
        // Demo 4: Basic Watcher
        createApp({
            data() {
                return {
                    watchedValue: '',
                    previousValue: '',
                    changeCount: 0
                }
            },
            watch: {
                watchedValue(newVal, oldVal) {
                    this.previousValue = oldVal;
                    this.changeCount++;
                    console.log(`Value changed from "${oldVal}" to "${newVal}"`);
                }
            }
        }).mount('#demo4');
        
        // Demo 5: Async Watcher
        createApp({
            data() {
                return {
                    username: '',
                    loading: false,
                    userData: ''
                }
            },
            watch: {
                username(newVal) {
                    if (newVal.length < 3) {
                        this.userData = '';
                        return;
                    }
                    
                    this.loading = true;
                    this.userData = '';
                    
                    setTimeout(() => {
                        this.userData = `User data for: ${newVal}`;
                        this.loading = false;
                    }, 1000);
                }
            }
        }).mount('#demo5');
        
        // Demo 6: Shopping Cart
        createApp({
            data() {
                return {
                    products: [
                        { id: 1, name: 'Apple', price: 1.50, quantity: 0 },
                        { id: 2, name: 'Banana', price: 0.80, quantity: 0 },
                        { id: 3, name: 'Cherry', price: 3.00, quantity: 0 }
                    ],
                    discountCode: '',
                    warningShown: false
                }
            },
            computed: {
                totalPrice() {
                    return this.products.reduce((sum, product) => {
                        return sum + (product.price * product.quantity);
                    }, 0);
                },
                itemCount() {
                    return this.products.reduce((sum, product) => {
                        return sum + product.quantity;
                    }, 0);
                },
                discount() {
                    return this.discountCode === 'SAVE10' ? 0.1 : 0;
                },
                finalPrice() {
                    return this.totalPrice * (1 - this.discount);
                }
            },
            watch: {
                totalPrice(newVal) {
                    if (newVal > 100 && !this.warningShown) {
                        alert('Total exceeds $100!');
                        this.warningShown = true;
                    } else if (newVal <= 100) {
                        this.warningShown = false;
                    }
                }
            }
        }).mount('#demo6');
    </script>
</body>
</html>

